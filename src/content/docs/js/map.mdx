---
title: Map
description: An overview of the MapVec, Map1D and Map2D classes and their associated methods methods.
sidebar:
  order: 4
---

The classes in this section allow arbitrary $1\times2$ or $2\times2$ matrices to be multiplied by vectors.

## `MapVec`

The `MapVec` provides a generic vector type that 2-dimensional mapping operations can return, and provides methods to be converted into a [`Pitch`](/js/pitch) or [`Interval`](/js/pitch) vector as required.

`MapVec` follows the shape of `Pitch` and `Interval`, exposing two fields:

```ts
x: number;
y: number;
```

### Class Constructor

```ts
constructor(x: number, y: number);
```

Simple pass in coordinates to instantiate a vector:

```ts
let v = new MapVec(12, 5);
```

### `toPitch`

```ts
toPitch(): Pitch;
```

Converts a `MapVec` into a `Pitch` vector.

```ts
let v = new MapVec(25, 10);
let p = v.toPitch();

p.w; // 25
p.h; // 10
```

### `toInterval`

```ts
toInterval(): Interval;
```

Converts a `MapVec` into an `Interval` vector.

```ts
let v = new MapVec(5, 2);
let m = v.toInterval();

p.w; // 5
p.h; // 2
```

## `Map1D`

A `Map1D` is a $1\times2$ matrix, used to map a 2-dimensional vector to a 1-dimensional number. Conceptually, many of Meantonal's `Pitch` and `Interval` queries utilise this principle under the hood (see the [Learn](/learn/maps) page for a detailed explanation).

### Class Constructor

```ts
constructor(m0: number, m1: number);
```

Creates a matrix $[m0, m1]$:

```ts
let A = new Map1D(5, 3);
```

### `map`

```ts
map(v: MapVec | Pitch | Interval): number;
```

Carries out the mapping operation on the passed in vector. Result will be a number.

```ts
let A = new Map(5, 3); // 31EDO mapping matrix
let p = SPN.toPitch("G4");

A.map(p); // sends p to 18, essentially a MIDI style mapping for 31EDO
```

### `compose`

```ts
compose(map: Map2D): Map1D;
```

Composes the `Map1D` instance with a passed in `Map2D`; essentially carries out matrix multiplication:

$$
[a_0, a_1]
\begin{bmatrix} b_{00} & b_{01} \\ b_{10} & b_{11} \end{bmatrix}
= [c_0, c_1]
$$

Returns a new `Map1D`. Creating new maps from the composition of existing maps can save on unnecessary computation.

## `Map2D`

A `Map1D` is a $2\times2$ matrix, used to map a 2-dimensional vector to another 2-dimensional vector. Essentially effects a change of coordinate system: (see the [Learn](/learn/maps) page for a detailed explanation).

### Class Constructor

```ts
constructor(m00: number, m01: number, m10: number, m11: number);
```

Creates a matrix: $\begin{bmatrix} m00 & m01 \\ m10 & m11 \end{bmatrix}$

```ts
let A = new Map2D(1, 2, 3, 4);
```

### `map`

```ts
map(v: MapVec | Pitch | Interval): MapVec;
```

Carries out the mapping operation on the passed in vector. Result will be a generic `MapVec`.

```ts
let A = new Map2D(2, -5, -1, 3); // basis change: (w, h) => (P5, P8)
let p = SPN.toPitch("E5");

A.map(p) // (4, 3)
```

### `compose`

```ts
compose(map: Map2D): Map2D;
```

Composes the `Map2D` instance with a passed in `Map2D`; essentially carries out matrix multiplication:

$$
\begin{bmatrix} a_{00} & a_{01} \\ a_{10} & a_{11} \end{bmatrix}
\begin{bmatrix} b_{00} & b_{01} \\ b_{10} & b_{11} \end{bmatrix}
=
\begin{bmatrix} c_{00} & c_{01} \\ c_{10} & c_{11} \end{bmatrix}
$$

Returns a new `Map2D`. Creating new maps from the composition of existing maps can save on unnecessary computation.

## `TuningMap`

A `TuningMap` represents a map onto a given tuning system, and is used to produce frequency values for [`Pitch`](/js/pitch) vectors in that tuning. It is specified in terms of:
- The width of its fifth in cents:
- The name of a reference pitch in [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).
- The frequency of that reference pitch in Hz.

If no reference pitch is given, the default C4 = 261.6255653Hz. This is equivalent to A4 = 440Hz in 12TET, but is centered about C4.

### Class Constructor

```ts
constructor(
    fifth: number,
    referencePitch?: string,
    referenceFreq?: number
);
```

Creates a `TuningMap` instance.

### `fromEDO`

```ts
static fromEDO(
    edo: number,
    referencePitch?: string,
    referenceFreq?: number
): TuningMap;
```

If you're working with EDO tuning system, it can be more convenient to initialise a `TuningMap` by specifying the number of parts the octave is divided into rather than the specific width of a perfect fifth in cents within that system. This static method allows just that.

As with the class constructor, if the reference `Pitch` and its frequency are not specified, defaults to C4 = 261.6255653Hz.

```ts
const T = TuningMap.fromEDO(31);

let p = Pitch("C4");
T.toHz(p); // ~261.63Hz

let m = Interval("M3");
T.toCents(m); // ~387.10 cents
```

### `toHz`

```ts
toHz(p: Pitch): number;
```

Returns the frequency of the passed-in `Pitch` in Hertz.

```ts
const T = TuningMap.fromEDO(12, "A4", 440);

let p = SPN.toPitch("A4");
T.toHz(p); // 440

p = SPN.toPitch("A5");
T.toHz(p); // 880
```

### `toCents`

```ts
toCents(m: Interval): number;
```

Returns the width of the passed in `Interval` in cents.

```ts
const T = TuningMap.fromEDO(12);

let m = Interval.fromName("M3");
T.toCents(m); // 400
```

### `toRatio`

```ts
toRatio(m: Interval): number;
```

returns the ratio of the passed `Interval` as a decimal number.

```ts
const T = TuningMap.fromEDO(31);

let m = Interval.fromName("A6");
T.toRatio(m); // 1.7489046221194973
```
