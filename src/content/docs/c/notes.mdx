---
title: Notes
description: Reference page for functions that create, transform or query Note vectors.
sidebar:
  order: 2
---

This page details all the functions that create, transform or query [`Note`](/c/types/#note) vectors.

## Creating Notes

`Note` vectors can obviously be initialised directly:

```c
Note p = { 25, 10 }; // initialised to middle C
```

It's often more convenient, however, to be able to create new `Note`s from old, or to assign them values by parsing strings in accepted formats.

### `note_from_spn`

```c
int note_from_spn(const char *s, Note *out);
```

Parses a `Note` from [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation). Outputs the `Note` via an out-param (you must pass in a pointer to a `Note`). Returns 1 if there is a parsing error.

Safe usage if the string is being passed in dynamically:

```c
Note p;
if (int note_from_spn(str, &p)) {
    // handle parsing error
}
```

## Common Queries

These functions query commonly required information from `Note` vectors.

### `note_chroma`

```c
int note_chroma(Note p);
```

Returns the number of perfect fifths (signed) separating a `Note` from C. Abstracts octave information away.

### `note_letter`

```c
int note_letter(Note p);
```

Returns the _offset_ of a `Note`'s letter from 'A' / 'a'. It's up to you to add 'A' or 'a' to the result to get an actual character though!

### `note_accidental`

```c
int note_accidental(Note p);
```

Returns a `Note`'s accidental as an offset from $\natural$, so:

|                |     |
| :------------: | :-: |
| $\sharp\sharp$ |  2  |
|    $\sharp$    |  1  |
|   $\natural$   |  0  |
|    $\flat$     | -1  |
|  $\flat\flat$  | -2  |

etc. for triple sharps/flats and beyond.

### `note_octave`

```c
int note_octave(Note p);
```

Returns the [SPN](https://en.wikipedia.org/wiki/Scientific_pitch_notation) octave number of a `Note`. Middle C is 4.

### `note_midi`

```c
int note_midi(Note p);
```

Returns the standard MIDI value for a given `Note`.

### `notes_equal`

```c
bool notes_equal(Note p, Note q);
```

Predicate function that checks whether two `Note` vectors are equal. Note that it does **not** check whether they are enharmonically equivalent: they must literally represent the same note in [SPN](https://en.wikipedia.org/wiki/Scientific_pitch_notation) to return `true`.

### `notes_enharmonic`

```c
bool notes_enharmonic(Note m, Note n, int edo);
```

Predicate function that checks whether two `Note` vectors are enharmonics in a given EDO tuning system. The third parameter 'edo' is for passing in the tuning system to check against. So for example:

```c
Note p, q;
note_from_spn("C#4", &p);
note_from_spn("Db4", &q);
notes_enharmonic(p, q, 12); // true; C# and Db are enharmonic in 12tet
notes_enharmonic(p, q, 31); // false; C# and Db are not enharmonic in 31tet

note_from_spn("Gbb4", &p);
note_from_spn("Ex4", &q);
notes_enharmonic(p, q, 31); // true; Gbb and Ex are enharmonic in 31tet
notes_enharmonic(p, q, 12); // false; Gbb and Ex are not enharmonic in 12tet
```

## Maps and Transformations

### `transpose_real`

```c
Note transpose_real(Note p, Interval m);
```

This function takes a `Note` and an `Interval`, and returns a new `Note` formed by their sum.

### `note_map_1d`

```c
int note_map_1d(Note p, Map1d T);
```

This function allows an arbitrary `Map1d` linear map to be applied to a `Note`, sending it to some integer. Allows things like:

```c
note_map_1d(p, ED31);
```

This would send any `Note` to a 31-tone equal temperament equivalent of MIDI numbering, such that:

|   |                     |
|:-:|:-------------------:|
| 0 | $\sf{C}_{-1}$       |
| 1 | $\sf{D}ùÑ´_{-1}$      |
| 2 | $\sf{C}\sharp_{-1}$ |
| 3 | $\sf{D}\flat_{-1}$  |
| 4 | $\sf{C}ùÑ™_{-1}$      |
| 5 | $\sf{D}_{-1}$       |
| 6 | $\sf{E}ùÑ´_{-1}$      |

*and so on...*

### `note_map_2d`

```c
MappedVec note_map_2d(Note p, Map2d T);
```

This function allows an arbitrary `Map2d` linear map to be applied to a `Note`, essentially facilitating a [change of basis](https://en.wikipedia.org/wiki/Change_of_basis). The returned vector is therefore of a unique type: [`MappedVec`](/c/types/#mappedvec).

This could be useful if working with generalised isomorphic keyboard layouts. For example, if reading numbers off a grid intended to represent a [Wicki-Hayden layout](https://en.wikipedia.org/wiki/Wicki%E2%80%93Hayden_note_layout), they could be parsed into Meantonal `Note` vectors simply:

```c
typedef struct {
    int x, y;
} Key;

Note note_from_key(Key k) {
    // casts becaues note_map_2d expects Note and returns MappedVec.
    return (Note) note_map_2d((Note) k, WICKI_FROM);
}
```

### `axis_create`

```c
MirrorAxis axis_create(Note p, Note q);
```

Creates a [`MirrorAxis`](/c/types/#mirroraxis) about which to invert `Note`s by adding two `Note` vectors together. To be used in conjunction with [`note_invert`](/c/notes/#note_invert).

### `axis_from_spn`

```c
int axis_from_spn(char *p_str, char *q_str, MirrorAxis *out);
```

Creates a [`MirrorAxis`](/c/types/#mirroraxis) about which to invert `Note`s by adding two `Note` vectors together. To be used in conjunction with [`note_invert`](/c/notes/#note_invert).

Unlike [`axis_create`](/c/notes/#axis_create), `axis_from_spn` takes two note names as [SPN](https://en.wikipedia.org/wiki/Scientific_pitch_notation) *strings*, and returns the created `MirrorAxis` via a passed in pointer. Returns 1 if there is a parsing error.

Safe usage if the strings are being passed in dynamically:

```c
MirrorAxis a;
if (int axis_from_spn(str1, str2, &a)) {
    // handle parsing error
}

```
### `note_invert`

```c
Note note_invert(Note p, MirrorAxis a);
```

Invert a `Note` about a passed in `MirrorAxis`, returning a new `Note` (the result of subtracting `p` from `a`). Inversion is **real**, not **diatonic**.

## Conversions

### `note_to_standard`

```c
StandardNote note_to_standard(Note p);
```

Converts from Meantonal's standard [`Note`](/c/types/#note) representation to the [`StandardNote`](/c/types/#standardnote) representation. Useful as a preliminary step to rendering standard notation.

### `note_from_standard`

```c
Note note_from_standard(StandardNote p);
```

Converts from the [`StandardNote`](/c/types/#standardnote) type back to a regular [`Note`](/c/types/#note) vector.
