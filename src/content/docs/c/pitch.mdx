---
title: Pitch
description: Reference page for functions that create, transform or query Pitch vectors.
sidebar:
  order: 2
---

import { Aside } from '@astrojs/starlight/components';

This page details all the functions that create, transform or query [`Pitch`](/c/types/#pitch) vectors.

## Creating Pitches

`Pitch` vectors can be initialised directly:

```c
Pitch p = { 25, 10 }; // initialised to middle C
```

It's often more convenient, however, to be able to create a new `Pitch` from existing vectors, or to assign them values by [parsing strings in accepted formats](/c/parse).

### `pitch_from_chroma`

```c
Pitch pitch_from_chroma(int chroma, int octave);
```

Creates a `Pitch` vector from a specified chroma (signed distance from C in 5ths) and octave (following [SPN](https://en.wikipedia.org/wiki/Scientific_pitch_notation) numbering).

## Common Queries

These functions query commonly required information from `Pitch` vectors.

### `pitch_chroma`

```c
int pitch_chroma(Pitch p);
```

Returns the number of perfect fifths (signed) separating a `Pitch` from C. Abstracts octave information away.

### `pitch_letter`

```c
int pitch_letter(Pitch p);
```

Returns the _offset_ of a `Pitch`'s letter from 'A' / 'a'. It's up to you to add 'A' or 'a' to the result to get an actual character though!

### `pitch_accidental`

```c
int pitch_accidental(Pitch p);
```

Returns a `Pitch`'s accidental as an offset from $\natural$, so:

|                |     |
| :------------: | :-: |
| $\sharp\sharp$ |  2  |
|    $\sharp$    |  1  |
|   $\natural$   |  0  |
|    $\flat$     | -1  |
|  $\flat\flat$  | -2  |

etc. for triple sharps/flats and beyond.

### `pitch_octave`

```c
int pitch_octave(Pitch p);
```

Returns the [SPN](https://en.wikipedia.org/wiki/Scientific_pitch_notation) octave number of a `Pitch`. Middle C is 4.

### `pitch_midi`

```c
int pitch_midi(Pitch p);
```

Returns the standard MIDI value for a given `Pitch`.

<Aside type="caution">

There is no guarantee a given pitch can be accurately represented by the MIDI standard. It is up to you to check whether the resulting number is between 0 and 127.

</Aside>

### `pitch_pc12`

```c
int pitch_pc12(Pitch p);
```

Returns the 12-tone pitch class number of a `Pitch` (C is 0).

### `steps_between`

```c
static inline int steps_between(Pitch p, Pitch q);
```

Returns the (signed) number of diatonic steps between two pitches. Calculated as $q - p$.

### `pitches_equal`

```c
bool pitches_equal(Pitch p, Pitch q);
```

Predicate function that checks whether two `Pitch` vectors are equal.

<Aside type="caution">

`pitches_equal` does **not** check whether pitches are enharmonically equivalent: they must literally represent the same *vector*.

</Aside>

### `pitches_enharmonic`

```c
bool pitches_enharmonic(Pitch m, Pitch n, int edo);
```

Predicate function that checks whether two `Pitch` vectors are enharmonics in a given EDO tuning system. The third parameter 'edo' is for passing in the tuning system to check against. So for example:

```c
Pitch p, q;
pitch_from_spn("C#4", &p);
pitch_from_spn("Db4", &q);
pitches_enharmonic(p, q, 12); // true; C# and Db are enharmonic in 12tet
pitches_enharmonic(p, q, 31); // false; C# and Db are not enharmonic in 31tet

pitch_from_spn("Gbb4", &p);
pitch_from_spn("Ex4", &q);
pitches_enharmonic(p, q, 31); // true; Gbb and Ex are enharmonic in 31tet
pitches_enharmonic(p, q, 12); // false; Gbb and Ex are not enharmonic in 12tet
```

### `pitch_highest`

```c
Pitch pitch_highest(Pitch arr[], int len, TuningMap T);
```

This function takes a `Pitch[]` array and a `TuningMap`, and returns the highest `Pitch` in the array. Uses the passed-in `TuningMap` to decide which `Pitch` is "higher" than the others.

```c
char *names[10] = {"B#3", "C4", "D4",  "D#4", "Eb4",
                   "E4",  "F4", "Ex4", "F#4", "Gb4"};
Pitch arr[10];
for (int i = 0; i < 10; i++) {
    pitch_from_spn(names[i], arr + i);
}

TuningMap T = tuning_map_from_edo(12, (Pitch){29, 11}, 440);

Pitch highest = pitch_highest(arr, 10, T); // highest now holds Gb4
```

### `pitch_lowest`

```c
Pitch pitch_lowest(Pitch arr[], int len, TuningMap T);
```

This function takes a `Pitch[]` array and a `TuningMap`, and returns the lowest `Pitch` in the array. Uses the passed-in `TuningMap` to decide which `Pitch` is "lower" than the others.

```c
char *names[10] = {"B#3", "C4", "D4",  "D#4", "Eb4",
                   "E4",  "F4", "Ex4", "F#4", "Gb4"};
Pitch arr[10];
for (int i = 0; i < 10; i++) {
    pitch_from_spn(names[i], arr + i);
}

TuningMap T = tuning_map_from_edo(12, (Pitch){29, 11}, 440);

Pitch lowest = pitch_lowest(arr, 10, T); // lowest now holds B#3
```

### `pitch_nearest`

```c
Pitch pitch_nearest(Pitch p, Pitch arr[], int len, TuningMap T);
```

This function takes a `Pitch`, a `Pitch[]` array and a `TuningMap`, and returns the closest `Pitch` in the array to the `Pitch` passed via the first argument. Uses the passed-in `TuningMap` to decide which `Pitch` is "closer" than the others.

```c
char *names[10] = {"B#3", "C4", "D4",  "D#4", "Eb4",
                   "E4",  "F4", "Ex4", "F#4", "Gb4"};
Pitch arr[10];
for (int i = 0; i < 10; i++) {
    pitch_from_spn(names[i], arr + i);
}

Pitch target;
pitch_from_spn("Gbb4", &target);

TuningMap T = tuning_map_from_edo(12, (Pitch){29, 11}, 440);
Pitch nearest = pitch_nearest(target, arr, 10, T); // nearest now holds F4

T = tuning_map_from_edo(31, reference, 440);
nearest = pitch_nearest(target, arr, 10, T); // nearest now holds Ex4
```

## Transformations

### `transpose_real`

```c
Pitch transpose_real(Pitch p, Interval m);
```

This function takes a `Pitch` and an `Interval`, and returns a new `Pitch` formed by their sum.

### `axis_create`

```c
MirrorAxis axis_create(Pitch p, Pitch q);
```

Creates a [`MirrorAxis`](/c/types/#mirroraxis) about which to invert a `Pitch` by adding two `Pitch` vectors together. To be used in conjunction with [`pitch_invert`](/c/pitch/#pitch_invert).

### `pitch_invert`

```c
Pitch pitch_invert(Pitch p, MirrorAxis a);
```

Invert a `Pitch` about a passed in `MirrorAxis`, returning a new `Pitch` (the result of subtracting `p` from `a`). Inversion is **real**, not **diatonic**.

## Conversions

### `pitch_to_standard`

```c
StandardPitch pitch_to_standard(Pitch p);
```

Converts from Meantonal's standard [`Pitch`](/c/types/#pitch) representation to the [`StandardPitch`](/c/types/#standardpitch) representation. Useful as a preliminary step to rendering standard notation.

### `pitch_from_standard`

```c
Pitch pitch_from_standard(StandardPitch p);
```

Converts from the [`StandardPitch`](/c/types/#standardpitch) type back to a regular [`Pitch`](/c/types/#pitch) vector. Conversion in this direction is generally less used, but the `StandardPitch` might represent a convenient parsing target to then extract `Pitch` vectors from if you are working with a notation format [Meantonal's parse functions](/c/parse) don't cover.
