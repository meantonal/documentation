---
title: Map
description: Reference page for the generic vector mapping funcitons.
sidebar:
  order: 5
---

This page details functions that apply linear maps to generic 2d vectors. Many of Meantonal's built-in functions that operate on `Pitch` and `Interval` vectors are essentially performing these maps under the hood, but these generalised mapping operations are available in case something you need isn't a built-in.

### `map_to_1d`

```c
int map_to_1d(MapVec v, Map1d T);
```

This function allows an arbitrary `Map1d` matrix to multiply a `MapVec`, sending it to some integer. Allows things like:

```c
map_to_1d((MapVec)p, ED31);
```

This would send any `Pitch` to a 31-tone equal temperament equivalent of MIDI numbering, such that:

$0\rightarrow\sf{C}_{-1}$

$1\rightarrow\sf{D}\flat\flat_{-1}$

$2\rightarrow\sf{C}\sharp_{-1}$

$3\rightarrow\sf{D}\flat_{-1}$

$4\rightarrow\sf{C}\sharp\sharp_{-1}$

$5\rightarrow\sf{D}_{-1}$

$6\rightarrow\sf{E}\flat\flat_{-1}$

*and so on...*

### `map_compose_1d_2d`

```c
static inline Map1D map_compose_1d_2d(Map1D A, Map2D B);
```

Composes a `Map1D` with a `Map2D`; essentially carries out matrix multiplication:

$$
[a_0, a_1]
\begin{bmatrix} b_{00} & b_{01} \\ b_{10} & b_{11} \end{bmatrix}
= [c_0, c_1]
$$

Returns a new `Map1D`. Creating new maps from the composition of existing maps can save on unnecessary computation.

### `map_to_2d`

```c
MappedVec map_to_2d(MapVec v, Map2d T);
```

This function allows an arbitrary `Map2d` matrix to multiply a `MapVec`. If it's an invertible matrix, this essentially facilitates a [change of basis](https://en.wikipedia.org/wiki/Change_of_basis). The returned vector is another `MapVec`.

This could be useful if working with generalised isomorphic keyboard layouts. For example, if reading numbers off a grid intended to represent a [Wicki-Hayden layout](https://en.wikipedia.org/wiki/Wicki%E2%80%93Hayden_pitch_layout), they could be parsed into Meantonal `Pitch` vectors simply:

```c
typedef struct {
    int x, y;
} WickiKey;

Pitch pitch_from_key(WickiKey k) {
    return (Pitch) map_to_2d((MapVec) k, WICKI_FROM);
}
```

### `map_compose_2d_2d`

```c
static inline Map2D map_compose_2d_2d(Map2D A, Map2D B);
```

Composes a `Map2D` with another `Map2D`; essentially carries out matrix multiplication:

$$
\begin{bmatrix} a_{00} & a_{01} \\ a_{10} & a_{11} \end{bmatrix}
\begin{bmatrix} b_{00} & b_{01} \\ b_{10} & b_{11} \end{bmatrix}
=
\begin{bmatrix} c_{00} & c_{01} \\ c_{10} & c_{11} \end{bmatrix}
$$

Returns a new `Map2D`. Creating new maps from the composition of existing maps can save on unnecessary computation.

### `tuning_map_from_fifth`

```c
TuningMap tuning_map_from_fifth(double fifth, Pitch ref_pitch, double ref_freq);
```

Construct a [`TuningMap`](/c/types/#tuningmap) from the width of the fifth in the target tuning system in cents, along with a reference [`Pitch`](/c/types/#pitch) and its frequency in the tuning in Hertz (e.g. A4 = 440Hz).

### `tuning_map_from_edo`

```c
TuningMap tuning_map_from_edo(int edo, Pitch ref_pitch, double ref_freq);
```

Construct a [`TuningMap`](/c/types/#tuningmap) for an EDO tuning system from the number of parts the octave will be divided into, along with a reference [`Pitch`](/c/types/#pitch) and its frequency in the tuning in Hertz (e.g. A4 = 440Hz).

### `to_hz`

```c
double to_hz(Pitch p, TuningMap T);
```

Returns the frequency of a [`Pitch`](/c/types/#pitch) in a given tuning in Hertz.

```c
Pitch p;
pitch_from_spn("C4");
TuningMap T = tuning_map_from_edo(12, "C4", CONCERT_C4);

to_hz(p); // 261.6255653
```

### `to_ratio`

```c
double to_ratio(Interval m, TuningMap T);
```

Returns a decimal approximation of the ratio of an [`Interval`](/c/types/#interval) in a given tuning system.

```c
Interval m;
interval_from_name("A6");
TuningMap T = tuning_map_from_edo(31, "C4", CONCERT_C4);

to_ratio(m, T); // 1.7489046221194973 (very close to 7/4)
```

### `to_cents`

```c
double to_cents(Interval m, TuningMap T);
```

Returns the width of an [`Interval`](/c/types/#interval) in a given tuning system in cents.

```c
Interval m;
interval_from_name("P5");
TuningMap T = tuning_map_from_edo(31, "C4", CONCERT_C4);

to_cents(m, T); // 696.7741935483871
```
